<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mamba — Call-Graph Construction</title>
  <!-- MathJax for proper formula rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /*****  PALETTE  *****/
    :root {
      --accent: #0a84ff;
      --text: #1c1c1e;
      --bg: #ffffff;
      --card: #f3f4f6;
      --code: #f5f5f7;
      --max: 820px;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --text: #e7e7e7;
        --bg: #26262a;
        --card: #323236;
        --code: #2a2a2e;
      }
    }
    /*****  RESET & BASE  *****/
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      display: flex;
      justify-content: center;
      padding: 3rem 1rem;
    }
    main { max-width: var(--max); width: 100% }
    /*****  TYPOGRAPHY  *****/
    h1 { font-size: 2.4rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem }
    h2 { font-size: 1.6rem; font-weight: 600; text-align: center; margin: 2.5rem 0 1.2rem }
    p, li { font-size: 1rem; margin-bottom: .6rem }
    /*****  COMPONENTS  *****/
    .box {
      background: var(--card);
      padding: 1.8rem;
      border-radius: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,.05);
      margin-bottom: 2rem;
    }
    pre {
      background: var(--code);
      padding: 1.5rem;
      border-radius: 20px;
      overflow: auto;
      font-size: .9rem;
      margin-bottom: 2rem;
    }
    code { font-family: "SFMono-Regular", Consolas, Menlo, monospace; tab-size: 2 }
    ul { padding-left: 1.4rem; list-style: square }
    ol { margin-left: 1.2rem }
    a { color: var(--accent); text-decoration: none; font-weight: 500 }
    a:hover { text-decoration: underline }
    footer { text-align: center; margin-top: 3.5rem; font-size: .85rem }
  </style>
</head>
<body>
  <main>
    <h1>Call-Graph Construction</h1>

 <h2>Problem definition</h2>
  <div class="box">
    <p>A call graph is an artifact produced by program analysis tools to record the <b>relationships between a function and the functions it calls</b>. Building a callgraph,  like many static analysis, is known to be an <b>undecidable</b> problem, meaning there is no perfect solution to build a perfect static callgraph. It relies on tricks and techniques to approximate the best callgraph possible. 
    <br><br>Numerous techniques exist to improve callgraph generation at compile time, such as <b>Reach Analysis</b>b>, <b>Class Hierarchy Analysis</b>, <b>Rapid type Analysis</b>, etc. <br>Most of these techniques are useful in an Object Oriented program paradigm, since this tool focuses more on Rust the solution differs a bit. (Maybe in the future supports for OOP languages will be added)<br>
    <br>Call-graph analysis on Rust’s LLVM IR is easier because:<br>
    - Generics are monomorphised → almost every call is a direct <code>call @func_name</code>, not a virtual or template dispatch.<br>
    - No class inheritance tree → you don’t need CHA or RTA; there’s no subtype hierarchy to walk.<br>
    - Only two kinds of indirect calls:<br>
        - <b>Trait objects (dyn Trait)</b> lowered to <b>v-tables</b> we can parse<br>
        - <b>Function pointers</b> tracked by simple points-to or metadata<br>
    <br><b>Monomorphization</b> is the process where the compiler takes a generic function or type (one written to work over any type T) and, at compile time, generates a separate, concrete version for each actual type it’s used with.<br>
    <br>We solve both in our fixed-point loop by:<br>
    - Seeding the points-to sets with<br>
        - Every function pointer stored in a <code>@vtable.* global</code> (trait-object slots).<br>
        - Every function whose address is “taken” and stored in some variable (raw function pointers).<br>
    - Propagating those seeds along all pointer‐flow edges (loads, stores, bitcasts, φ-nodes, GEPs).<br>
    - Resolving each indirect <code>call %p(...)</code> by looking up the final points-to set <code>pts[%p]</code> and adding an edge to every function in it.<br>
    <br>Because monomorphized generic calls show up as call @foo_u32 or call @foo_String (i.e. direct <code>getCalledFunction()</code> hits), the algorithm does nothing special for generics: they already appear as direct edges in step 1 of each iteration.<br>
    </p>
  </div>

    <h2>Plain text algorithm</h2>
    <div class="box">
      <p>We repeat these steps until we add no new edges:</p>
      <ol>
        <li>
          <strong>Walk every basic block:</strong>
          <ul>
            <li>On a direct call, add an edge: <code>caller → callee</code>.</li>
            <li>On an indirect call, remember the call site and its pointer variable.</li>
            <li>On any pointer operation (store, load, bitcast, GEP, φ-node, return, parameter), record that the source pointer can flow to the destination pointer.</li>
          </ul>
        </li>
        <li>
          <strong>Pointer-tracking phase:</strong>
          <ul>
            <li><strong>Seed:</strong> For each pointer variable, start its set with every function from v-table slots and every address-taken function.</li>
            <li><strong>Flood:</strong> While any variable’s set grows, copy its new functions into every variable it can flow to.</li>
          </ul>
        </li>
        <li>
          <strong>Resolve indirect calls:</strong>
          <ul>
            <li>For each remembered indirect call site, look up its variable’s final function set.</li>
            <li><strong>Build our graph</strong> by adding edges from the caller to each function in that set.</li>
            <li>If any new edge was added, repeat from step 1.</li>
          </ul>
        </li>
      </ol>
    </div>

    <h2>Pseudo-code</h2>
    <pre><code>repeat until we add no new edges

1. walk every basic block
     • direct call   → add caller → callee edge
     • indirect call → remember call-site + operand
     • pointer copy  → remember edge  src ↦ dst
       (store, load, bitcast, getelementptr, φ, return, param)

2. pointer-tracking phase
     • seed: every v-table slot + address-taken function
     • work-list flood:
         while some P(v) just grew
             for (v → w) in copy-edges  push w
             P(w) ← P(w) ∪ (new funcs)

3. resolve remembered indirect calls
     • for each call-site c
         for t in P(op(c))   add caller(c) → t
         if any edge new   repeat outer loop</code></pre>

    <h2>Mathematical Formulation</h2>
    <div class="box" style="background: var(--code); padding: 1rem;">
      <div style="font-size: 1.3em; text-align: center; margin-bottom: 1rem;">
        $$P^* \;=\; \mathrm{lfp}_P\!\Bigl(v \;\mapsto\; \mathrm{Seeds}(v)\;\cup\;\bigcup_{(u,v)\in E}P(u)\Bigr)$$
        $$\mathrm{CG} \;=\; \bigl\{\,(\mathrm{caller}(c),\,t)\mid c\in C,\;
          t\in
          \begin{cases}
            \{\mathrm{callee}(c)\} & \text{if $c$ is direct},\\[4pt]
            P^*(\mathrm{op}(c))     & \text{if $c$ is indirect}
          \end{cases}\bigr\}$$
      </div>
      <p><em>Notation:</em></p>
      <ul>
        <li><strong>CG</strong> — The call graph—the set of caller→callee edges</li>
        <li><strong>=</strong> — “equals” or “is defined as”</li>
        <li><strong>{ … }</strong> — A set</li>
        <li><strong>( , )</strong> — 	An ordered pair or tuple</li>
        <li><strong>caller</strong> — A function mapping each call‑site c to the function that contains it</li>
        <li><strong>(c)</strong> — 	The call‑site being considered</li>
        <li><strong>t</strong> —  A variable ranging over possible callee functions</li>
        <li><strong>∣ (“such that”)</strong> — 	Introduces the conditions that select which pairs belong to the set</li>
        <li><strong>c ∈ C</strong> — The call‑site c is one element of the set C of all call‑sites</li>
        <li><strong>,</strong> — 	“and” (both conditions must hold)</li>
        <li><strong>t ∈ …</strong> — 	The target t must come from the following case‑analysis result</li>
        <li><strong>{…​</strong> — A two‑branch definition depending on whether c is direct or indirect</li>
        <li><strong>{callee(c)}</strong> — If c is direct, the singleton set containing the statically resolved callee</li>
        <li><strong>{…​</strong> — A two‑branch definition depending on whether c is direct or indirect</li>
        <li><strong>P*</strong> — The least fixed point of the points‑to mapping PP</li>
        <li><strong>op(c)</strong> — The SSA value (pointer) used by the indirect call at call‑site c</li>
        <li><strong>P*(op(c))/strong> — “All functions that the pointer op(c) may refer to”</li>
      </ul>
    </div>

    <footer>
      <a href="index.html">← Back to main page</a>
    </footer>
  </main>
</body>
</html>
