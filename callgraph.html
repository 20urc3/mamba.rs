<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mamba — Call‑Graph Construction</title>
<style>
/*****  PALETTE  *****/
:root{
  --accent:#0a84ff;
  --text:#1c1c1e;
  --bg:#ffffff;
  --card:#f3f4f6;
  --code:#f5f5f7;
  --max:820px;
}
@media(prefers-color-scheme:dark){
  :root{
    --text:#e7e7e7;
    --bg:#26262a;
    --card:#323236;
    --code:#2a2a2e;
  }
}
/*****  RESET & BASE  *****/
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
  background:var(--bg);
  color:var(--text);
  line-height:1.7;
  display:flex;
  justify-content:center;
  padding:3rem 1rem;
}
main{max-width:var(--max);width:100%}

/*****  TYPOGRAPHY  *****/
h1{font-size:2.4rem;font-weight:700;text-align:center;margin-bottom:1.5rem}
h2{font-size:1.6rem;font-weight:600;text-align:center;margin:2.5rem 0 1.2rem}
p,li{font-size:1rem;margin-bottom:.6rem}

/*****  COMPONENTS  *****/
.box{
  background:var(--card);
  padding:1.8rem;
  border-radius:24px;
  box-shadow:0 4px 12px rgba(0,0,0,.05);
  margin-bottom:2rem;
}
pre{
  background:var(--code);
  padding:1.5rem;
  border-radius:20px;
  overflow:auto;
  font-size:.9rem;
  margin-bottom:2rem;
}
code{font-family:"SFMono-Regular",Consolas,Menlo,monospace;tab-size:2}
ul{padding-left:1.4rem;list-style:square}
a{color:var(--accent);text-decoration:none;font-weight:500}
a:hover{text-decoration:underline}
footer{text-align:center;margin-top:3.5rem;font-size:.85rem}
</style>
</head>
<body>
<main>
  <h1>Call‑Graph Construction</h1>

  <h2>Problem definition</h2>
  <div class="box">
    <p>A call graph is an artifact produced by program analysis tools to record the <b>relationships between a function and the functions it calls</b>. Building a callgraph,  like many static analysis, is known to be an <b>undecidable</b> problem, meaning there is no perfect solution to build a perfect static callgraph. It relies on tricks and techniques to approximate the best callgraph possible. 
    <br>Numerous techniques exist to improve callgraph generation at compile time, such as <b>Reach Analysis</b>b>, <b>Class Hierarchy Analysis</b>, <b>Rapid type Analysis</b>, etc. <br>Most of these techniques are useful in an Object Oriented program paradigm, since this tool focuses more on Rust the solution differs a bit. (Maybe in the future supports for OOP languages will be added)<br>
    <br>Call-graph analysis on Rust’s LLVM IR is easier because:<br>
    - Generics are monomorphised → almost every call is a direct <code>call @func_name</code>, not a virtual or template dispatch.<br>
    - No class inheritance tree → you don’t need CHA or RTA; there’s no subtype hierarchy to walk.<br>
    - Only two kinds of indirect calls:<br>
        - <b>Trait objects (dyn Trait)</b> lowered to <b>v-tables</b> we can parse<br>
        - <b>Function pointers</b> tracked by simple points-to or metadata<br>
    <br><b>Monomorphization</b> is the process where the compiler takes a generic function or type (one written to work over any type T) and, at compile time, generates a separate, concrete version for each actual type it’s used with.<br>
    <br>We solve both in our fixed-point loop by:<br>
    - Seeding the points-to sets with<br>
        - Every function pointer stored in a <code>@vtable.* global</code> (trait-object slots).<br>
        - Every function whose address is “taken” and stored in some variable (raw function pointers).<br>
    - Propagating those seeds along all pointer‐flow edges (loads, stores, bitcasts, φ-nodes, GEPs).<br>
    - Resolving each indirect <code>call %p(...)</code> by looking up the final points-to set <code>pts[%p]</code> and adding an edge to every function in it.<br>
    <br>Because monomorphized generic calls show up as call @foo_u32 or call @foo_String (i.e. direct <code>getCalledFunction()</code> hits), the algorithm does nothing special for generics—they already appear as direct edges in step 1 of each iteration.<br>
    </p>
  </div>
  
  <h2>Plain text algorithm</h2>
  <div class="box">
    <p>Each variable’s points‑to set starts with its own address‑taken functions and grows by absorbing everything that flows along copies (assignments, loads, stores, …); iterate until no set changes. The final points‑to map drives all call‑graph edges.</p>
  </div>

  <h2>Pseudo‑code</h2>
  <pre><code>repeat until we add no new edges

  1. walk every basic block
       • direct call   → add caller → callee edge
       • indirect call → remember call‑site + operand
       • pointer copy  → remember edge  src ↦ dst
         (store, load, bitcast, getelementptr, φ, return, param)

  2. pointer‑tracking phase
       • seed: every v‑table slot + address‑taken function
       • work‑list flood:
           while some P(v) just grew
               for (v → w) in copy‑edges  push w
               P(w) ← P(w) ∪ (new funcs)

  3. resolve remembered indirect calls
       • for each call‑site c
           for t in P( op(c) )   add caller(c) → t
           if any edge new   repeat outer loop</code></pre>

  <h2>Mathematical Formulation</h2>
  <div class="box" style="background:var(--code)">
    <p><em>Notation.</em></p>
    <ul>
      <li><strong>F</strong> — set of all LLVM functions</li>
      <li><strong>C</strong> — set of all call‑site instructions</li>
      <li><code>caller(c)</code> — function containing call‑site <cite>c</cite></li>
      <li><code>callee(c)</code> — direct callee when <cite>c</cite> is direct</li>
      <li><code>op(c)</code>    — SSA value holding the callee pointer</li>
    </ul>

<pre><code>P*  =  lfp_P ( v ↦ Seeds(v) ∪ ⋃_{(u,v)∈E} P(u) )
</code></pre>
    <p style="margin-top:-.6rem">where <em>E</em> is the set of pointer‑copy edges.</p>

<pre><code>CG = { ( caller(c) , t ) │ c∈C ,
        t ∈  { callee(c) }          if c direct
            ∪ P*( op(c) )           if c indirect }
</code></pre>
    <p style="margin-top:-.6rem">Each pair (<code>caller</code>, <code>t</code>) forms a call‑graph edge.</p>
  </div>

  <footer>
    <a href="index.html">← Back to main page</a>
  </footer>
</main>
</body>
</html>
