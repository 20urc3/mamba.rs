<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mamba — Call-Graph Construction</title>
  <!-- MathJax for proper formula rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /*****  PALETTE  *****/
    :root {
      --accent: #0a84ff;
      --text: #1c1c1e;
      --bg: #ffffff;
      --card: #f3f4f6;
      --code: #f5f5f7;
      --max: 820px;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --text: #e7e7e7;
        --bg: #26262a;
        --card: #323236;
        --code: #2a2a2e;
      }
    }
    /*****  RESET & BASE  *****/
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      display: flex;
      justify-content: center;
      padding: 3rem 1rem;
    }
    main { max-width: var(--max); width: 100% }
    /*****  TYPOGRAPHY  *****/
    h1 { font-size: 2.4rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem }
    h2 { font-size: 1.6rem; font-weight: 600; text-align: center; margin: 2.5rem 0 1.2rem }
    p, li { font-size: 1rem; margin-bottom: .6rem }
    /*****  COMPONENTS  *****/
    .box {
      background: var(--card);
      padding: 1.8rem;
      border-radius: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,.05);
      margin-bottom: 2rem;
    }
    pre {
      background: var(--code);
      padding: 1.5rem;
      border-radius: 20px;
      overflow: auto;
      font-size: .9rem;
      margin-bottom: 2rem;
    }
    code { font-family: "SFMono-Regular", Consolas, Menlo, monospace; tab-size: 2 }
    ul { padding-left: 1.4rem; list-style: square }
    ol { margin-left: 1.2rem }
    a { color: var(--accent); text-decoration: none; font-weight: 500 }
    a:hover { text-decoration: underline }
    footer { text-align: center; margin-top: 3.5rem; font-size: .85rem }
  </style>
</head>
<body>
  <main>
    <h1>Call-Graph Construction</h1>

    <h2>Problem definition</h2>
    <div class="box">
      <p>
        A call graph is an artifact produced by program analysis tools to record the <b>relationships between a function and the functions it calls</b>. Building a callgraph, like many static analyses, is known to be an <b>undecidable</b> problem, meaning there is no perfect solution to build a perfect static callgraph. It relies on tricks and techniques to approximate the best callgraph possible.
        <br><br>
        Numerous techniques exist to improve callgraph generation at compile time, such as <b>Reach Analysis</b>, <b>Class Hierarchy Analysis</b>, <b>Rapid Type Analysis</b>, etc. Most of these techniques are useful in an Object Oriented program paradigm; since this tool focuses on Rust, the solution differs a bit. (Maybe in the future support for OOP languages will be added.)
        <br><br>
        Call-graph analysis on Rust’s LLVM IR is easier because:
      </p>
      <ul>
        <li>Generics are monomorphised → almost every call is a direct <code>call @func_name</code>, not a virtual or template dispatch.</li>
        <li>No class inheritance tree → you don’t need CHA or RTA; there’s no subtype hierarchy to walk.</li>
        <li>Only two kinds of indirect calls:
          <ul>
            <li><b>Trait objects (dyn Trait)</b> lowered to <b>v-tables</b> we can parse</li>
            <li><b>Function pointers</b> tracked by simple points-to or metadata</li>
          </ul>
        </li>
      </ul>
      <p>
        <b>Monomorphization</b> is the process where the compiler takes a generic function or type (one written to work over any type <code>T</code>) and, at compile time, generates a separate, concrete version for each actual type it’s used with.
      </p>
      <p>
        We solve both in our fixed-point loop by:
      </p>
      <ul>
        <li>Seeding the points-to sets with:
          <ul>
            <li>Every function pointer stored in a <code>@vtable.* global</code> (trait-object slots).</li>
            <li>Every function whose address is “taken” and stored in some variable (raw function pointers).</li>
          </ul>
        </li>
        <li>Propagating those seeds along all pointer‑flow edges (loads, stores, bitcasts, φ-nodes, GEPs).</li>
        <li>Resolving each indirect <code>call %p(...)</code> by looking up the final points-to set <code>pts[%p]</code> and adding an edge to every function in it.</li>
      </ul>
      <p>
        Because monomorphized generic calls show up as <code>call @foo_u32</code> or <code>call @foo_String</code> (i.e. direct <code>getCalledFunction()</code> hits), the algorithm does nothing special for generics: they already appear as direct edges in step 1 of each iteration.
      </p>
      <p><strong>Key insight:</strong> we don’t just scan for direct calls—we first run a <em>flow-insensitive</em> points-to analysis over the entire IR to conservatively resolve all function-pointer targets. That initial points-to graph seeds our indirect‑call edges and lets us iterate to a much more precise call graph.</p>
    </div>

    <h2>Plain text algorithm</h2>
    <div class="box">
      <p>We repeat these steps until we add no new edges:</p>
      <ol>
        <li>
          <strong>Walk every basic block (using FI points-to info):</strong>
          <p><em>Prerequisite:</em> have initial points-to sets for all function‑pointer variables, computed by a fast flow-insensitive pass.</p>
          <ul>
            <li>On a direct call, add an edge: <code>caller → callee</code>.</li>
            <li>On an indirect call, look up the variable’s current FI points-to set (<code>P<sub>FI</sub>[p]</code>) and add a provisional edge to <em>each</em> potential target; remember this call-site for later refinement.</li>
            <li>On any pointer operation (store, load, bitcast, GEP, φ-node, return, parameter), record that the source pointer can flow to the destination pointer.</li>
          </ul>
        </li>
        <li>
          <strong>Pointer-tracking phase:</strong>
          <ul>
            <li><strong>Seed:</strong> Initialize each pointer’s set with its FI points-to results (all v-table slots & address-taken functions).</li>
            <li><strong>Flood:</strong> Propagate those seeds along pointer‑flow edges to refine the points-to graph before each call-resolution pass.</li>
          </ul>
        </li>
        <li>
          <strong>Resolve indirect calls:</strong>
          <p><em>Using the refined points-to graph from Step 2…</em></p>
          <ul>
            <li>For each remembered indirect call site, look up its variable’s final function set.</li>
            <li><strong>Build our graph</strong> by adding edges from the caller to each function in that set.</li>
            <li>If any new edge was added, repeat from step 1.</li>
          </ul>
        </li>
      </ol>
    </div>

    <h2>Pseudo-code</h2>
    <pre><code>repeat until we add no new edges

1. walk every basic block
     • direct call   → add caller → callee edge
     • indirect call → remember call-site + operand
     • pointer copy  → remember edge  src ↦ dst
       (store, load, bitcast, getelementptr, φ, return, param)

2. pointer-tracking phase
     • seed: every v-table slot + address-taken function
     • work-list flood:
         while some P(v) just grew
             for (v → w) in copy-edges  push w
             P(w) ← P(w) ∪ (new funcs)

3. resolve remembered indirect calls
     • for each call-site c
         for t in P(op(c))   add caller(c) → t
         if any edge new   repeat outer loop</code></pre>

    <h2>Mathematical Formulation</h2>
    <div class="box" style="background: var(--code); padding: 1rem;">
      <div style="font-size: 1.3em; text-align: center; margin-bottom: 1rem;">
        $$P^* \;=\; \mathrm{lfp}_P\!\Bigl(v \;\mapsto\; \mathrm{Seeds}(v)\;\cup\;\bigcup_{(u,v)\in E}P(u)\Bigr)$$
        $$\mathrm{CG} \;=\; \bigl\{\,(\mathrm{caller}(c),\,t)\mid c\in C,\;
          t\in
          \begin{cases}
            \{\mathrm{callee}(c)\} & \text{if $c$ is direct},\\[4pt]
            P^*(\mathrm{op}(c))     & \text{if $c$ is indirect}
          \end{cases}\bigr\}$$
      </div>
      <p><em>Here, the least-fixed-point computation of <code>P<sup>*</sup></code> is exactly our FI points-to pass—its results feed directly into <code>CG</code> to resolve indirect calls.</em></p>
      <p><em>Notation:</em></p>
      <ul>
        <li><strong>CG</strong> — The call graph—the set of caller→callee edges</li>
        <li><strong>=</strong> — “equals” or “is defined as”</li>
        <li><strong>{ … }</strong> — A set</li>
        <li><strong>( , )</strong> — An ordered pair or tuple</li>
        <li><strong>caller</strong> — A function mapping each call‑site <code>c</code> to the function that contains it</li>
        <li><strong>c</strong> — The call‑site being considered</li>
        <li><strong>t</strong> — A variable ranging over possible callee functions</li>
        <li><strong>∣ (“such that”)</strong> — Introduces the conditions that select which pairs belong to the set</li>
        <li><strong>c ∈ C</strong> — The call‑site <code>c</code> is one element of the set <code>C</code> of all call‑sites</li>
        <li><strong>,</strong> — “and” (both conditions must hold)</li>
        <li><strong>t ∈ …</strong> — The target <code>t</code> must come from the following case‑analysis result</li>
        <li><strong>{…}</strong> — A two‑branch definition depending on whether <code>c</code> is direct or indirect</li>
        <li><strong>{callee(c)}</strong> — If <code>c</code> is direct, the singleton set containing the statically resolved callee</li>
        <li><strong>P*</strong> — The least fixed point of the points‑to mapping <code>P</code></li>
        <li><strong>op(c)</strong> — The SSA value (pointer) used by the indirect call at call‑site <code>c</code></li>
        <li><strong>P*(op(c))</strong> — “All functions that the pointer <code>op(c)</code> may refer to”</li>
      </ul>
    </div>

    <footer>
      <a href="index.html">← Back to main page</a>
    </footer>
  </main>
</body>
</html>
