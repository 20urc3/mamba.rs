<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mamba — Call‑Graph Construction</title>
<style>
/*****  PALETTE  *****/
:root{
  --accent:#0a84ff;
  --text:#1c1c1e;
  --bg:#ffffff;
  --card:#f3f4f6;
  --code:#f5f5f7;
  --max:820px;
}
@media(prefers-color-scheme:dark){
  :root{
    --text:#e7e7e7;
    --bg:#26262a;
    --card:#323236;
    --code:#2a2a2e;
  }
}
/*****  RESET & BASE  *****/
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
  background:var(--bg);
  color:var(--text);
  line-height:1.7;
  display:flex;
  justify-content:center;
  padding:3rem 1rem;
}
main{max-width:var(--max);width:100%}

/*****  TYPOGRAPHY  *****/
h1{font-size:2.4rem;font-weight:700;text-align:center;margin-bottom:1.5rem}
h2{font-size:1.6rem;font-weight:600;text-align:center;margin:2.5rem 0 1.2rem}
p,li{font-size:1rem;margin-bottom:.6rem}

/*****  COMPONENTS  *****/
.box{
  background:var(--card);
  padding:1.8rem;
  border-radius:24px;
  box-shadow:0 4px 12px rgba(0,0,0,.05);
  margin-bottom:2rem;
}
pre{
  background:var(--code);
  padding:1.5rem;
  border-radius:20px;
  overflow:auto;
  font-size:.9rem;
  margin-bottom:2rem;
}
code{font-family:"SFMono-Regular",Consolas,Menlo,monospace;tab-size:2}
ul{padding-left:1.4rem;list-style:square}
a{color:var(--accent);text-decoration:none;font-weight:500}
a:hover{text-decoration:underline}
footer{text-align:center;margin-top:3.5rem;font-size:.85rem}
</style>
</head>
<body>
<main>
  <h1>Call‑Graph Construction</h1>

  <h2>Problem definition</h2>
  <div class="box">
    <p>A call graph is an artifact produced by program analysis tools to record the <b>relationships between a function and the functions it calls</b>. Building a callgraph,  like many static analysis, is known to be an <b>undecidable</b> problem, meaning there is no perfect solution to build a perfect static callgraph. It relies on tricks and techniques to approximate the best callgraph possible. 
    <br><br>Numerous techniques exist to improve callgraph generation at compile time, such as <b>Reach Analysis</b>b>, <b>Class Hierarchy Analysis</b>, <b>Rapid type Analysis</b>, etc. <br>Most of these techniques are useful in an Object Oriented program paradigm, since this tool focuses more on Rust the solution differs a bit. (Maybe in the future supports for OOP languages will be added)<br>
    <br>Call-graph analysis on Rust’s LLVM IR is easier because:<br>
    - Generics are monomorphised → almost every call is a direct <code>call @func_name</code>, not a virtual or template dispatch.<br>
    - No class inheritance tree → you don’t need CHA or RTA; there’s no subtype hierarchy to walk.<br>
    - Only two kinds of indirect calls:<br>
        - <b>Trait objects (dyn Trait)</b> lowered to <b>v-tables</b> we can parse<br>
        - <b>Function pointers</b> tracked by simple points-to or metadata<br>
    <br><b>Monomorphization</b> is the process where the compiler takes a generic function or type (one written to work over any type T) and, at compile time, generates a separate, concrete version for each actual type it’s used with.<br>
    <br>We solve both in our fixed-point loop by:<br>
    - Seeding the points-to sets with<br>
        - Every function pointer stored in a <code>@vtable.* global</code> (trait-object slots).<br>
        - Every function whose address is “taken” and stored in some variable (raw function pointers).<br>
    - Propagating those seeds along all pointer‐flow edges (loads, stores, bitcasts, φ-nodes, GEPs).<br>
    - Resolving each indirect <code>call %p(...)</code> by looking up the final points-to set <code>pts[%p]</code> and adding an edge to every function in it.<br>
    <br>Because monomorphized generic calls show up as call @foo_u32 or call @foo_String (i.e. direct <code>getCalledFunction()</code> hits), the algorithm does nothing special for generics—they already appear as direct edges in step 1 of each iteration.<br>
    </p>
  </div>
  
  <h2>Plain text algorithm</h2>
  <div class="box">
    <p>We repeat the following steps until we add no new edges:</p>
    <ol>
      <li>
        <strong>Walk every basic block:</strong>
        <ul>
          <li>When we see a direct call, we add an edge from the caller function to the callee function.</li>
          <li>When we see an indirect call through a variable, we remember that call site and which variable holds the function pointer.</li>
          <li>When we see any instruction that moves or copies a pointer—like <code>store</code>, <code>load</code>, <code>bitcast</code>, <code>getelementptr</code>, φ-nodes, <code>return</code>, or parameter passing—we record that the source pointer can flow to the destination pointer.</li>
        </ul>
      </li>
      <li>
        <strong>Pointer-tracking phase:</strong>
        <ul>
          <li><strong>Seed:</strong> Give each pointer variable a starting list of functions from every v-table slot and every function whose address was taken.</li>
          <li><strong>Flood:</strong> As long as any variable’s list grows, copy its new functions into every variable it can flow to.</li>
        </ul>
      </li>
      <li>
        <strong>Resolve remembered indirect calls:</strong>
        <ul>
          <li>For each indirect call site, look up the final list of functions for its pointer variable.</li>
          <li>Build our graph by adding an edge from the caller to each function in that list.</li>
          <li>If we added any new edges, go back to step 1 and repeat.</li>
        </ul>
      </li>
    </ol>
  </div>

  <h2>Pseudo‑code</h2>
  <pre><code>repeat until we add no new edges

  1. walk every basic block
       • direct call   → add caller → callee edge
       • indirect call → remember call‑site + operand
       • pointer copy  → remember edge  src ↦ dst
         (store, load, bitcast, getelementptr, φ, return, param)

  2. pointer‑tracking phase
       • seed: every v‑table slot + address‑taken function
       • work‑list flood:
           while some P(v) just grew
               for (v → w) in copy‑edges  push w
               P(w) ← P(w) ∪ (new funcs)

  3. resolve remembered indirect calls
       • for each call‑site c
           for t in P( op(c) )   add caller(c) → t
           if any edge new   repeat outer loop</code></pre>

  <h2>Mathematical Formulation</h2>
  <div class="box" style="background:var(--code); padding:1rem;">
    <div style="font-size:1.2em; text-align:center; margin-bottom:1rem;">
      <pre><code>P*  =  lfp<sub>P</sub>( v ↦ Seeds(v) ∪ ⋃<sub>(u,v)∈E</sub> P(u) )</code></pre>
      <pre><code>CG = { ( caller(c), t ) │ c∈C,
           t ∈ { callee(c) }        if c is direct
             ∪ P*( op(c) )         if c is indirect }</code></pre>
    </div>
    <p><em>Notation:</em></p>
    <ul>
      <li><strong>F</strong> — set of all LLVM functions</li>
      <li><strong>C</strong> — set of all call-site instructions</li>
      <li><code>caller(c)</code> — the function containing call-site <cite>c</cite></li>
      <li><code>callee(c)</code> — the direct target when <cite>c</cite> is a direct call</li>
      <li><code>op(c)</code> — the SSA value that holds the callee pointer for <cite>c</cite></li>
      <li><strong>Seeds(v)</strong> — initial set of functions whose addresses flow into variable <code>v</code></li>
      <li><strong>E</strong> — set of pointer-copy edges (store, load, bitcast, getelementptr, φ, parameter passing)</li>
      <li><strong>P*</strong> — the least fixed point of the mapping <code>P ↦ v ↦ Seeds(v) ∪ ⋃<sub>(u,v)∈E</sub> P(u)</code></li>
      <li><strong>CG</strong> — the final call graph as a set of (caller, callee) edges</li>
    </ul>
  </div>

  <footer>
    <a href="index.html">← Back to main page</a>
  </footer>
</main>
</body>
</html>
