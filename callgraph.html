<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mamba — Call-Graph Construction</title>
  <!-- MathJax for proper formula rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /*****  PALETTE  *****/
    :root {
      --accent: #0a84ff;
      --text: #1c1c1e;
      --bg: #ffffff;
      --card: #f3f4f6;
      --code: #f5f5f7;
      --max: 820px;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --text: #e7e7e7;
        --bg: #26262a;
        --card: #323236;
        --code: #2a2a2e;
      }
    }
    /*****  RESET & BASE  *****/
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      display: flex;
      justify-content: center;
      padding: 3rem 1rem;
    }
    main { max-width: var(--max); width: 100% }
    /*****  TYPOGRAPHY  *****/
    h1 { font-size: 2.4rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem }
    h2 { font-size: 1.6rem; font-weight: 600; text-align: center; margin: 2.5rem 0 1.2rem }
    p, li { font-size: 1rem; margin-bottom: .6rem }
    /*****  COMPONENTS  *****/
    .box {
      background: var(--card);
      padding: 1.8rem;
      border-radius: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,.05);
      margin-bottom: 2rem;
    }
    pre {
      background: var(--code);
      padding: 1.5rem;
      border-radius: 20px;
      overflow: auto;
      font-size: .9rem;
      margin-bottom: 2rem;
    }
    code { font-family: "SFMono-Regular", Consolas, Menlo, monospace; tab-size: 2 }
    ul { padding-left: 1.4rem; list-style: square }
    ol { margin-left: 1.2rem }
    a { color: var(--accent); text-decoration: none; font-weight: 500 }
    a:hover { text-decoration: underline }
    footer { text-align: center; margin-top: 3.5rem; font-size: .85rem }
  </style>
</head>
<body>
  <main>
    <h1>Call-Graph Construction</h1>

    <h2>Problem definition</h2>
    <div class="box">
      <p>A call graph is an artifact produced by program analysis tools to record the <b>relationships between a function and the functions it calls</b>. Building a call graph, like many static analyses, is known to be <b>undecidable</b>: there’s no perfect solution for every possible program. Instead we use tricks and approximations.</p>
      <p>On Rust’s LLVM IR, call-graph analysis is easier because:</p>
      <ul>
        <li>Generics are <b>monomorphized</b> → nearly every call appears as a direct <code>call @func_name</code>, not virtual dispatch.</li>
        <li>No class inheritance tree → no need for CHA or RTA.</li>
        <li>Only two kinds of indirect calls:
          <ul>
            <li><b>Trait objects</b> (`dyn Trait`) lowered to <code>@vtable.*</code> globals.</li>
            <li><b>Function pointers</b> tracked by simple points-to or metadata.</li>
          </ul>
        </li>
      </ul>
    </div>

    <h2>Plain text algorithm</h2>
    <div class="box">
      <p>We repeat these steps until we add no new edges:</p>
      <ol>
        <li>
          <strong>Walk every basic block:</strong>
          <ul>
            <li>On a direct call, add an edge: <code>caller → callee</code>.</li>
            <li>On an indirect call, remember the call site and its pointer variable.</li>
            <li>On any pointer operation (store, load, bitcast, GEP, φ-node, return, parameter), record that the source pointer can flow to the destination pointer.</li>
          </ul>
        </li>
        <li>
          <strong>Pointer-tracking phase:</strong>
          <ul>
            <li><strong>Seed:</strong> For each pointer variable, start its set with every function from v-table slots and every address-taken function.</li>
            <li><strong>Flood:</strong> While any variable’s set grows, copy its new functions into every variable it can flow to.</li>
          </ul>
        </li>
        <li>
          <strong>Resolve indirect calls:</strong>
          <ul>
            <li>For each remembered indirect call site, look up its variable’s final function set.</li>
            <li><strong>Build our graph</strong> by adding edges from the caller to each function in that set.</li>
            <li>If any new edge was added, repeat from step 1.</li>
          </ul>
        </li>
      </ol>
    </div>

    <h2>Pseudo-code</h2>
    <pre><code>repeat until we add no new edges

1. walk every basic block
     • direct call   → add caller → callee edge
     • indirect call → remember call-site + operand
     • pointer copy  → remember edge  src ↦ dst
       (store, load, bitcast, getelementptr, φ, return, param)

2. pointer-tracking phase
     • seed: every v-table slot + address-taken function
     • work-list flood:
         while some P(v) just grew
             for (v → w) in copy-edges  push w
             P(w) ← P(w) ∪ (new funcs)

3. resolve remembered indirect calls
     • for each call-site c
         for t in P(op(c))   add caller(c) → t
         if any edge new   repeat outer loop</code></pre>

    <h2>Mathematical Formulation</h2>
    <div class="box" style="background: var(--code); padding: 1rem;">
      <div style="font-size: 1.3em; text-align: center; margin-bottom: 1rem;">
        $$P^* \;=\; \mathrm{lfp}_P\!\Bigl(v \;\mapsto\; \mathrm{Seeds}(v)\;\cup\;\bigcup_{(u,v)\in E}P(u)\Bigr)$$
        $$\mathrm{CG} \;=\; \bigl\{\,(\mathrm{caller}(c),\,t)\mid c\in C,\;
          t\in
          \begin{cases}
            \{\mathrm{callee}(c)\} & \text{if $c$ is direct},\\[4pt]
            P^*(\mathrm{op}(c))     & \text{if $c$ is indirect}
          \end{cases}\bigr\}$$
      </div>
      <p><em>Notation:</em></p>
      <ul>
        <li><strong>F</strong> — set of all LLVM functions</li>
        <li><strong>C</strong> — set of all call-site instructions</li>
        <li><code>caller(c)</code> — function containing call-site <cite>c</cite></li>
        <li><code>callee(c)</code> — direct target when <cite>c</cite> is a direct call</li>
        <li><code>op(c)</code> — SSA value holding the callee pointer for <cite>c</cite></li>
        <li><strong>Seeds(v)</strong> — initial set of functions whose addresses flow into variable <code>v</code></li>
        <li><strong>E</strong> — set of pointer-copy edges (store, load, bitcast, getelementptr, φ, parameter passing)</li>
        <li><strong>P*</strong> — the least fixed point of <code>P ↦ [v ↦ Seeds(v) ∪ ⋃<sub>(u,v)∈E</sub> P(u)]</code></li>
        <li><strong>CG</strong> — the final call graph as a set of (caller, callee) edges</li>
      </ul>
    </div>

    <footer>
      <a href="index.html">← Back to main page</a>
    </footer>
  </main>
</body>
</html>
